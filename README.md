<h2># Spring Boot Test Project</h2>

<h3># Information</h3>

<h4>빌드</h4>
-소스코드 파일을 컴퓨터에서 실행할 수 있는 독립 소프트웨어 가공물로 변환하는 과정 또는 결과물</br>
-작성한 소스코드나 파일 및 자원 등을 WAS가 인식할 수 있는 구조로 패키징 하는 과정 및 결과물

<h4>빌드 도구</h4>
-빌드 도구란 프로젝트 생성, 테스트 빌드, 배포 등의 작업을 위한 전용 프로그램</br>
-늘어나는 라이브러리 추가, 라이브러리 버전 동기화의 어려움을 해소하고자 등장</br>
-초기에는 Ant를 많이 사용하였고 현재는 Maven, Gradle이 많이 쓰인다</br>

<h4>Maven</h4>
-자바용 프로젝트 관리 도구</br>
-프로젝트의 전체적인 생명주기(LifeCycle)를 관리하는 도구</br>
-필요한 라이브러리를 문서(pom.xml)에 정의해 놓으면 해당 라이브러리와 작동하는데 필요한 다른 라이브러리들까지 네트워크를 통해 자동으로 다운로드 받아준다</br>
-배포 관리가 가능하다</br>

<h4>Maven LifeCycle</h4>
-프로젝트 우측의 Maven -> LifeCycle에서 확인 가능하다</br>
-Default(Build): 일반적인 빌드 프로세스를 위한 모델</br>
-Clean: 빌드 시 생성되었던 파일을 삭제하는 단계</br>
-Validate: 프로젝트가 올바른지 확인하고 필요한 모든 정보를 사용할 수 있는지 확인하는 단계</br>
-Compile: 프로젝트의 소스코드를 컴파일 하는 단계</br>
-Test: 단위 테스트를 수행하는 단계</br>
-Package: 실제 컴파일된 소스코드와 리소스들을 jar, war등으로 배포하기 위한 패키지로 만드는 단계</br>
-Verify: 통합 테스트 결과에 대한 검사를 실행하여 품질 기준을 충족시키는지 확인하는 단계</br>
-Install: 패키지를 로컬 저장소에 설치하는 단계</br>
-Site: 프로젝트 문서와 사이트 작성, 생성하는 단계</br>
-Deploy: 만들어진 패키지를 원격 저장소에 릴리즈하는 단계</br>

<h4>Bean</h4>
-Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라고 한다</br>
-일반적으로 new 연산자를 통해 객체를 생성했을 때 그 객체는 Bean이 아니다</br>
-따라서 Bean을 등록하기 위해서는 @ComponentScan 어노테이션을 사용해서 빈을 등록한다.</br>
-또는 직접 Bean 설정 파일에 등록할 수도 있다. 자바 설정파일 클래스를 생성하고 @Configuration 어노테이션을 붙이고 그 안에 @Bean 어노테이션을 사용해 직접 Bean 정의가 가능하다.</br>

<h4>WEB-INF</h4>
-Web Information의 약자로 web에 관련된 정보를 의미한다.</br>
-WEB-INF폴더는 브라우저에서 직접적으로 접근이 불가능한 경로다. 따라서 브라우저에서 유저의 직접 접근이 어려워 보안성이 높다.</br>

<h4>Model과 ModelAndView의 차이</h4>
-Model은 파라미터 방식으로 메소드에 (Model model)파라미터를 넣어주고 String 형태로 리턴한다.</br>
-Model은 값을 넣을 때 .addAttribute()를 사용한다</br>
-public String Model(Model model){ model.addAttribute("name", "윤근상"); return "model"; }</br></br>

-ModelAndView는 컴포넌트 방식으로 ModelAndView 객체를 생성해서 객체형태로 리턴한다.</br>
-ModelAndView는 Model과 View를 합쳐놓은 것으로, 값을 넣을 때 .addObject()를 사용하고, setViewName()으로 보낼 곳의 View를 세팅한다.</br>
-Spring MVC가 @Controller 어노테이션을 지원하기 시작한 이후로 ModelAndView는 잘 사용하지 않는 편이다.</br>

<h4>Service와 ServiceImpl을 만드는 이유</h4>
-인터페이스는 객체의 사용방법을 정의한 타입이다. 다형성을 구현하는 중요한 역할을 한다. 즉 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있게 해준다.</br>
-많은 개발자들이 이에 대해 명확한 답변을 하지는 못한다. 나도 고민해보기</br>

<h4>RedirectAttributes</h4>
-폼 형식의 문서를 작성 후, 서버로 보내면 곧이어 다른 페이지로 리다이렉트 한다. 하지만 이런 리다이렉트 방식이 GET방식이기 때문에 데이터를 전송하게 되면 URL을 통해 파라미터가 노출되는 위험이 있다.</br>
-폼(POST)->Redirect->서버(GET)</br>
-따라서 스프링의 RedirectAttributes 클래스를 사용하면 리다이렉트가 발생하기 전에 플래시 속성을 세션에 복사하여(addFlashAttribute()메소드 사용) 저장된 플래시 속성을 세션에서 모델로 이동시킨다. 그러면 헤더에 파라미터를 붙이지 않기 떄문에 URL에 노출되지 않는다.</br>

<h4>유효성 검증</h4>
-Validator, Hibernate를 사용하여 유효성 검증을 한다.</h4>


<h3># Annotation</h3>

@SpringBootApplication: @Configuration, @EnableAutoConfiguration, @ComponentScan의 기능을 합쳐놓은 것. Spring Boot 프로젝트 생성시 Main 어플리케이션에서 선언되어 있기 때문에 자동으로 스프링의 기본적인 설정이 완료된다</br>
@Configuration: bean에 대해서 Context에 추가하거나 특정 클래스를 참조해올 수 있다</br>
@EnableAutoConfiguration: Spring Boot의 자동화 기능을 활성화 시켜준다</br>
@ComponentScan: 패키지내에 application 컴포넌트가 어디에 위치해있는지 검사한다</br>



<h3># jsp</h3>

form:form태그: form id= "command" action="{page_url}" method="post"와 같다</br>
commandName, ModelAttribute: 폼에 있는 요소의 값을 채우기위한 객체를 찾을때 사용할 이름을 지정한다. 스프링 5버전 이후로는 commandName에서 에러가 발생하기 때문에 ModelAttribute옵션을 사용한다.</br>
form태그의 요소에 값을 제공할 객체 지정은 컨트롤러에서 하게 된다.</br> 
ex)model.addAttribute("board", board(객체)); </br>
public String boardForm(@ModelAttribute board board, Model, model) throws Exception</br>
public String boardForm(@ModelAttribute("board") board vo, Model model) throws Exception</br>
board.setTitle 등의 방식으로 객체를 전달해줄 수 있다</br>

form:input 태그: input type="text" 태그와 같다</br>
form:password 태그: input type="password" 태그와 같다</br>
form:hidden 태그: input type="hidden" 태그와 같다</br>
path 속성을 통해 modelAttribute로 불러온 객체의 프로퍼티를 지정할 수 있다</br>

form:select 태그: select id name, option value 태그를 합친 것과 같다 items 속성을 통해 option을 지정한다</br>
form:options 태그: item 속성을 통해 option을 지정한다.</br>
form:option 태그:  option태그를 직접 지정한다</br>

form:checkboxes 태그: input type-"check box" 태그와 같다</br>
form:checkbox 태그: 태그를 직접 지정한다</br>

form:radiobuttons 태그: input type="radiobutton" 태그와 같다</br>
form:radiobutton 태그: 태그를 직접 지정한다.</br>

form:textarea 태그: <textarea>태그 와 같다</br>


<h3># HTML</h3>
-ul: unordered list, 순서 없이 나타내는 리스트</br>
-ol: ordered list, 숫자 순서대로 나타내는 리스트</br>

oracle연결이 안될시
maven 웹 페이지에서 ojdbc7.jar(12.1.0.2.0) 다운 후 WEB-INF/lib에 넣기<br>
maven에 dependency 추가
        <dependency>
            <groupId>oracle.jdbc</groupId>
            <artifactId>OracleDriver</artifactId>
            <version>12.1.0.2.0</version>
            <scope>system</scope>
            <systemPath>${basedir}/src/main/webapp/WEB-INF/lib/ojdbc7.jar</systemPath>
        </dependency>


## ch3.Using Spring Boot

### 3.1. Build System
Dependency 관리를 위해 빌드 도구를 선택한다. 추천하는 도구는 **Maven**과 **Gradle**이 있다.

#### 3.1.1. Maven
        -통합테스트를 실행하기 전에 실행가능한 jar, war를 패키징하고, spring boot 애플리케이션을 
        실행하고, 빌드정보를 생성한다
        -필요한 라이브러리를 특정 문서(pom.xml)에 정의해 놓으면 내가 사용할 라이브러리 뿐만 아니라
        해당 라이브러리가 작동하는데 필요한 다른 라이브러리들까지 관리하여 네트워크를 통해
        자동으로 다운 받는다
        -스프링 부트 의존관계는 org.springframework.boot groupId를 사용한다. 

[참조문서1]: https://goddaehee.tistory.com/199
[참조문서2]: https://docs.spring.io/spring-boot/docs/2.4.0-SNAPSHOT/maven-plugin/reference/htmlsingle/#using
참조
[https://goddaehee.tistory.com/199][참조문서1] </br>
[https://docs.spring.io/spring-boot/docs/2.4.0-SNAPSHOT/maven-plugin/reference/htmlsingle/#using][참조문서2]

#### 3.1.2. Gradle
        -Groovy 기반의 빌드도구이다. Maven의 pom.xml을 Gradle로 변환도 가능하며 Maven의 중앙 저장소도 지원하기 때문에 라이브러리를 모두 그대로 가져다 사용 가능하다
        -compile("org.springframework.boot:groupId)의 형식으로 의존성을 설정한다
        
[참조문서3]: https://docs.spring.io/spring-boot/docs/2.4.0-SNAPSHOT/maven-plugin/reference/htmlsingle/
참조
[https://docs.spring.io/spring-boot/docs/2.4.0-SNAPSHOT/maven-plugin/reference/htmlsingle/][참조문서3]

#### 3.1.3. Ant
        -긴 스크립트 작성을 해야하기 때문에 안쓰는 추세
        
#### 3.1.4. starter
starter 의존성은 spring-boot-starter-* 의 네이밍 구조를 를 갖는다
        
### 3.2. Structuring Your Code
기존의 Spring은 web.xml문서를 통해 메타정보를 활용,

CLI, GUI, NUI
제약사항, 시스템을 설계하거나 구현할 때 관련되는 기술이나 표준, 규정들을 의미한다 개발과 관련된 정책이나, 업무 규칙, 특정 소프트웨어나 프로그램의 사용, 데이터 사용과 관련된 제약 등에 대한 기술 제약사항, 개발할 때 적용할 업무 영역의 표준이나 법규의 표준 적합 제약사항으로 날ㅏ태==

u1개발도구 분류: 화면설계(파워포인트, 스토리보드, 와이어프레임, 목업) 
와이어프레임: 기획 단계에서 페이지 레이아웃이나 화면 이동, 구성요소에 대한 내용을 기술한 문서
스토리보드: 와이어프레임의 내용에 디스크립션 등을 포함한 설계 문서이다.
목업: 설계 단계에서 실제 화면과 같은 형태의 모형이다.
프로토타입: 인터렉션(상호작용)이 포함되어 테스트가 가능한 형태이다.
UI디자인: 화면의 모양이나 기능 등을 표현하는 것이다.
Ui설계서: 웹 사이트의 페이지 구성요소를 기록한 설계도이다. 정적인 형태의 화면 혀태로 와이어프레임이나 목입등을 이용하여 작업한다.

사용성: 특정한 목적을 성취하고자 하는 특정 사용자들에 의해 어떤 제품이 사용될 때와 같은 특정한 맥락의 사용에서의 효과성, 효율성, 만족도에 관한 것이다.
유용성: 사용자가 업무를 수행하는 데 있어 얼마나 정확하게 수행할 수 있는지를 나타내는 것이다.
정보구조: 설계 단계에서 사이트를 구성하는 처리 내용이나 메뉴의 구조를 표현함으로써 사이트의 구조를 파악해 줄 수 있도록 하는 것으로 시미트 맵이라고도 한다.
정보구조를 표현하는 방법에 따라, 계층적 구조, 계열 구조, 그리드 구조, 네트워크 구조비게이션: 네빅
네비게이션: 사용자가 사이트에서 원하는 정보를 찾도록 안내하는 것이다. 사이트맵과 관계가 있고 설계나 구현할 때 사용자가 중심이 되어야 한다, 네비게이션은 메뉴, 버튼, 링크 등으로 구성되며 이들 구성요소는 모든 페이지에서 일관성을 지켜 사용자로 하여금 혼동되지 않도록 하고, 사용자가 직권적으로 자신이 찾고 있는 정보를 알고 찾아간ㄴ 데 도둠을 줄 수 있도록  설계되어야 한다
유스케이스: 사용자 측면에서의 요구사항이며 주로 기능 개선에 대한 내용으로, 사용자가 원하는 목표를 위하여 시스템에서 수행해야하는 내용을 기술한다, 유스케이스에 기록된 내용을 토대로 실제 수행 방법을 구현하게 되다. 사용자에게 있어 외부 시스템이나 서브 시스템과의 의사소통 수단으로 사용된다. 하나의 단위 업무에 대한 독립적인 기능을 수행할 수 있도록 표현한다
UI구현지침 확인
W3C: 월드 와이드 웹을 위한 표준을 개발하고 장려하는 국제적인 컨소시엄 조직으로, W3C의 설립 취지는 웹의 지속적인 성장을 도모하는 프로토콜과 가이드라인을 개발하여 월드 와이드 웹의 모든 잠재력을 이끌어 낸다는 목적에서 찾을 수 있다.
한국형 웹 콘텐츠 접근성 지침: KWCAG, 장애인이 비장애인과 동등하게 웹 콘텐츠에 접근할 수 있도록 웹 콘텐츠를 제작하는 방법에 관하여 기술한 것이다. 웹 콘텐츠 저작자 및 개발자, 웹사이트 설계자 등이 장애인 접근성을 준수하여 콘텐츠를 쉽게 제작할 수 있도록 돕는 지침들을 제공하는 것이 목적이다. 기존의 인터넷 웹 콘텐츠 접근성 지침에 해외 웹 관련 표준 및 기술 동향을 최대한 반영하여 개정한 것ㅇ것이다 해외의 웹 콘텐츠 접근성 가이드라인 2.0을 국내에 맞게 반영한 것이다.
전자정부 웹 표준 준수 지침: 전자정부 웹 사이트 이용자가 특정 운영 체제나 웹 브라우저에 상관없이 접속할 수 있도록 전부에서 전자정부시스템 구축 시 반영해야하는 최소한의 규약을 정의한 것이다.
웹의 3요소: 웹표준, 웹에서 사용되는 기술이나 규칙을 의미하며, 웹사이트를 작성할때 이용하는 HTML, CSS, JavaScript 등에 대한 규정과 다른 기종이나 다른 플랫폼에서도 웹페이지가 구현되도록 제작하는 기법 등을 표함한다. 웹 접근성, 어떠한 사용자(장애인 노인 등), 어떠한 기술 환경에서도 사용자가 전문적인 능력 없이 웹사이트에서 제공하는 모든 정보에 접근할 수 있도록 보장하는 것을 뜻한다. 사용자 웹 접근성이란 모든 사용자가 웹 콘텐츠에 보다 손쉽게 접근할 수 있도록 웹 접근성 지침을 준수하여 설계하고, 실사용성을 고려하여 웹 사이트를 구현하였는지 여부의 수준을 의미한다. 웹호환성, 서비스 이용자 단말기의 하드웨어 및 소프트웨어 환경이 다른 경우에도 동등한 서비스를 제공하는 것을 의미한다.
UI구현
서버와 클라이언트
서버: 클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 또는 프로그램이다.
웹서버는 웹 브라우저(클라이언트)로부터 HTTP요청을 받아들이고, HTML문서를 ㅂㄴ환한다. 웹서버의 기능은 HTML, 문서(웹 페이지)를 클라이언트로 전달하는 것이다. HTML 문서(웹 페이지)에는 그림, CSS, 자바스크립트가 포함된다. 콘텐츠 제공뿐 아니라 클라이언트로부터 콘텐츠를 전달 받는 것도 웹 서버의 기능에 속한다. 서버 프로그램의 대표적인 종류에는 Apache, IIS, ngmix, GWS등이 있다.
클라이언트: 네트워크를 통하여 다른 서버 시스템 상의 컴퓨터에 원격 서비스에 접속할 수 있는 응용 프로그램이나 서비스를 클라이언트라고 한다. 웹 브라우저에 URL을 입력하여 그 URL에 해당하는 웹 서버로 웹 페이지에 대한 요청을 전달하는 것이 클라이언트의 기능이다. 클라이언트의 대표적인 종류로는 파이어폭스, 크로 ㅁIE드잉 있다
웹 사이트와 웹 페이지: 웹 사이트는 인터넷 프로토콜 기반의 네트워크에서 URll을 통하여 보이는 웹 페이지들의 의미 있는 묶음이다. 웹페이지는 월드 와이드 웹 상에 있는 개개의 문서를 의미한다. 
HTML: HTML은 마크업 언어로서 웹 페이지를 표현하는 언어이다. <!DOCTYPE html> 웹페이지가 HTML5 문서임을 의미. HTML5에는 반드시 표기해야 함. <html>~</html> HTML문서의 시작과 끝을 의미, <head> ~ </head> 스타일과 스크립트를 선언하는 부분, <title> ~ </title> 브라우저의 제목 표시, <body> ~ </body> 사용자에게 보여주는 실제 내용이 구현되는 부분, HTML의 모든 태그는 시작과 끝 태그로 이루어진다. HTML 태그에는 속성을 지정할 수 있다. 웹 브라우저에 보여지는 내용들을 표현한다. Header, 해당 페이지의 헤더 영역을 지정하고 주로 로고나 회사명, 사이트 맵, 로그인/회원가입 버튼, 검색 버튼 등이 위치한다. Navigation, 본문의 주요 내비게이션(메인 매뉴) 영역을 지정한다. Section, 해당 페이지 콘텐츠 영역을 지정할 때 사용하며 헤더, 푸터 태그와 비교해서 영역을 구분 지정할 때 사용한다. Article, 독립적인 콘텐츠 항목에 대한 영역을 지정할 떄 사용한다. Aside, 본문 내용 이외에 표현하고자 하는 기타 내용이 있을 경우에 영역을 지정할 때 사용하거나 서브 메뉴를 표시하고자 할 때 사용하기도 한다. Footer 본문 내용의  아래에 위치하도록 지정하여 주로 개인정보 보호정채그 회사 주소 등을 작성한다. 
CSS, 웹 페이지 전체의 일관성을 유지할 수 있도록 스타일을 미리 저장해 둔 시트를 의미한다. 웹 페이지를 HTML로만 작성할 경우에는 스타일 변경에 제약이 있으나, 스타일을 미리 저장해 두고 일부 내용이 스타일을 변경할 때 전체 페이지의 내용을 한꺼번에 처리할 수 있어 간편하고 페이지의 일관성을 유지할 수 있다.
CSS는 HTML 문서 내에 작성되거나 외부 파일 형태로 작성 가능하며,  CSS문법은 다음의 예와 같이 구성된다. 선택자는 스타일을 적용하기 위한 대상을 뜻하며, HTML 요소를 사용할 수도 있고 ID나 Class 형태로 정의할 수도 있다. 스타일은 다양한 형태로 지정할 수 있으며 속성:값 형태로 지정한다. 
CSS 선택자, 공용선택자, HTML 요소를 선택자로 하여 스타일을 적용할 수 있으며, 이 경우 해당 HTMl 요소 모두에 스타일이 적용된다. 태그선택자, 지정한 태그에 대하여 스타일이 적용된다. 클래스 선택자, 클래스 선택자를 활용하면 특정 HTML 요소들을 그룹화하여 스타일을 지정하는 것이 가능하다. 아이디 선택자, 특정 ID를 부여하여 ID에 스타일을 지정할 수 있다.
자바스크립트, 자바스크립트는 객체지향의 프로그래밍 언어로서 웹 브라우저에서 주로 사용된다, 자바스크립트를 이용하여 웹 페이지에서 발생하는 사용자 이벤트에 대한 처리가 가능하고, 자바스크립트의 내장 객체를 활용하면 다양한 형태의 웹 페이지를 구현할 수 있다.
자바스크립트느 HTML문서 내에서 <sciprt></script>태그를 통해 작성되고 작성되는 위치는 <head>영역, <body>영역이며 js확장자를 갖는 외부 파일 형태로 작성할 수 있다. 
<script>태그 내부의 자바스크립트 코드는 해당 HTML파일이 로딩될 때 한 번 실행된다. 이런 정적인 코드만을 사용할 경우 사용자 이벤트에 대한 다양한 처리에 어려움이 있으며, 이 때문에 HTML에서는 HTML태그의 여러 속성을 통해 자바스크립트 코드를 처리할 수 있도록 하고 있다. onclick: 버튼과 같은 HMTL의 다양한 폼 요소에서 지원하며 사용자가 해당 요소를 클릭할 때 동작한다. 만일 onclick 핸들러가 false를 반환할 경우에는 해당 요소의 어떠한 기능도 수행하지 않는다. onmousedown, onmouseup, onclick 핸들러오 ㅏ유사하게 동작하지만, 마우스를 누를 때와 놓았을 때를 구분하여 동작할 수 있다는 점이 다르다. onmouseover, onmouseout, 마우스의 포인터가 해당 요소의 위로 올라오거나 벗어날 떄 구동한다 onchange, <input>, <select>, <textarea>요소에서 지원하며 해당 요소의 입력 포커스를 다른 곳으로 이동할 떄 구동한다. onload <body>태그에서 사용되며 해당 페이지와 해당 페이지에 연결된 외부 내용들이 완전히 로딩 되었을 때 구동한다.
DOM과 자바스크립트의 관계, DOM은 자바스크립트에서 HTML 페이지의 요소에 접근하거나 변경할 수 있도록 한다. 웹브라우저는 웹 페이지가 로딩될 때 해당 페이지에 대한 DOM을 생성하며 이 HTMl DOM은 해당 페이지의 요소들을 아래와 같이 계층 구조를 갖는 형태로 나열한다. HTML DOM을 통해 자바스크립트는 다음과 같이 구현할 수 있다. 해당 페이지의 요소 변경이나 추가 삭제 해당 페이지의 요소에 대한 속성 변경이나 추가 해당 페이지의 CSS 변경이나 추가 삭제, 새로운 HTML 이벤트의 생성
UI테스트
사용성테스트, 사용성 테스트 기법은 UI테스트에 대한 보편적인 방법으로, 크게 사용성 테스트에 대한 게획 수립, 사용성 테스트 설계, 사용성 테스트 수행과 결과 검토로 구분하여 진행된다. 사용자의 제품 만족도 제고 제품의 완성까지의 노력 대비 높은 효율성, 개발 생산성 대비 낮은 에러, 쉬운 학습 이해도, 높은 품질의 완성도 상승, 사용자 실수 최소화 등의 효과를 달성할 수 있다.        
특징, 사용자가 웹 사이트를 사용하는 것을 전제로 분석하여 사이트 구성 메뉴의 문제점과 요구사항의 반영 여부를 점검하는 것이다. 웹사이트가 개발된 조건을 바탕으로 사용자가 접근하고 이용하는 측면에서 선호할만한 웹사이트의 기능을 테스트하는 것이다. 사용자의 요구사항에 맞는 웹 사이트를 만들어 내기 위하여 구현 전체 절차에 사용자의 재 요구사항이 반영되도록 하는 것이다.
사용성 테스트의 주의사항, 사용성에만 치중한 나머지 고객의 감성적인 측면에 그칠 수 있다. 기본 기능이 정확히 구현되었는지 검사하는 기본적인 기능 테스트에 대한 누락이 발생하지 않도록 주의한다. 테스트에 참여하는 인원이 자율적으로 테스트할 수 있는 환경이어야 좋은 품질 보장이 가능하다. 테스트할 때 자세한 기능 설명, 구현 방법에 대해서 충분한 테스트가 가능하도록 제공되어야 한다. 테스트가 오랜 시간 진행될 경우 중간에 어떤 사유에서 지연되는지 체크해야 한다.        
사용성 테스트 과정, 계획 수립, 목적 평가 내용 분석 사용 환경 사용자 등을 분석한다. 테스트 설계, 진행 절차 작성, 테스트 참가자 결정, 테스트 항목의 평가 방향 결정, 다양한 평가 방법으로 설계한다. 테스트 실행 설계된 진행 절차대로 진행한다. 결과 보고서 작성, 평가에 사용된 데이터를 분류하고 분석하며 결과를 통해 문제점을 분석한 후 수정에 필요한 의견을 포함하여 보고서를 작성함으로써 피드백을 통해 오류를 수정하도록 한다.
테스트 케이스의 작성, 테스트 케이스는 어떤 실행 환경에서 어떤 입력 값들을 부여하여 원하는 결과가 정확히 나오는지를 판단할 수 있도록 작성한다.
유효성 검사, HTML 문서 작성 후 문법 등 지켜야 할 많은 규칙들이 있다. HTML의 문법은 생각보다 복잡해서 완전히 외우기 쉽지 않고 익숙해진 후에도 간혹 실수를 하게 된다. 따라서 가장 좋은 방법은 유효성 검사 프로그램을 사용하여 자신이 작성하고 있는 HTML 문서를 최대한 자주 검사하는 것이다.        
화살표 함수는 함수를 간략히 기술할 수 있다. this를 묶는 것이 가능하다. const calcSum = (a, b, c) => { const result = a + b + c; return result;}; 화살표 함수의 정의가 한 줄인 경우 {}와 return을 생략할 수 있다
const calcSum = Function (a, b, c) { const result = a + b + c; return result;}      
함수의 파라미터 초깃값 설정, function calcSum(price, tax = 0.1) { const result = price + price * tax } calcSum(10000) 결과: 11000 calucSum(10000, 0.5) 결과: 150000
정해지지 않은 파라미터의 개수를 가지는 함수는 ...을 이용하여 ...파라미터와 같은 방식으로 정의한다. function calcSum(...prices) { let result = 0; for(const value of prices) { result += value;} return result; } calcSum(10, 20) 결과 30, calcSum(100, 200 300); 결과 600
자바스크립트는 웹페이지의 텍스트나 스타일을 변경할 수 있다. 이와 같이 HTML각 요소에 접근하는 방식은 DOM 인터페이스로 정의되어 있다. DOM은 트리 구조를 사용하여 HTML문서를 다룬다. 

트리의 각 구성요소를 노드라고 한다. 노드는 자바스크립트에서 Node객체로 취급하며, 요소를 가져오거나 추가하는 작업이 가능하다. Node 객체의 속성과 메소드는 노드.속성과 노드.메소드로 접근이 가능하다. HTML문서 전체의 요소는 document를 사용해 가져올 수 있으며, 그 자체가 커다란 Node 객체가 된다.
노드는 요소노드(태그), 속성노드(태그 속성), 텍스트노드(일반 텍스트)종류가 있다.
요소노드는 자바스크립트에서 element객체로 취급하며 요소의 데이터를 변경하거나 CSS클래스를 변경하는 등의 작업이 가능하다. 
DOM과 node의 차이??

Pandas는 열 중심 데이터 분석 API,
from __future__ import print_function
import pandas as pd
pd.__version__
Pandas의 기본 데이터 구조는 두 가지 클래스로 구현된다
DataFrame은 행 및 이름 지정된 열이 포함된 관계형 데이터 테이블
Series는 하나의 열이다. DataFrame에는 하나 이상의 Series와 각 Series의 이름이 포함된다

Series를 만드는 법은 Series 객체를 생성하는 것이다
pd.Series(['one', 'two', 'three'])



















